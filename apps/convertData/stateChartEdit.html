<!DOCTYPE html>
<html>

<head>
  <title>StateChart Data Editor</title>
  <style>
    .the-grid {
      display: grid;
      grid-template-columns: auto 8rem 1fr;
      column-gap: 0.5rem;
    }

    .the-display,
    .the-input {
      border: solid thin silver;
    }

    button {
      width: 100%;
    }
  </style>
</head>

<body>
  <h2>StateChart Data Editor</h2>
  <div class="the-grid">
    <div>
      <span class="label">Input</span>
      <a href="https://sketch.systems/tutorials/five-minute-introduction/">Format docs</a>
      <!-- Format: <select id="format">
        <option>Simple</option>
        <option>Sketch</option>
      </select> -->
    </div>
    <span class="label">Convert</span>
    <span class="label">Output</span>
    <div class="the-input">
      <textarea rows="30" cols="80" spellcheck="false" autocomplete="off" autocorrect="off"></textarea>
    </div>

    <div class="the-controls">
      <button id="b0">Raw</button>
      <button id="b1">DOT</button>
      <button id="b2">DOT2</button>
      <button id="b3">Bi-graph</button>
      <!-- <button id="b4">XState</button> -->
    </div>

    <div class="the-display">
      <textarea rows="30" cols="80" spellcheck="false" autocomplete="off" autocorrect="off"></textarea>
    </div>
  </div>
  <a href="./svgEdit.html">Simple SVG editor</a>
  <a href="./structureChartEdit.html">Structure Chart editor</a>
</body>
<script>
  {
    // Initial view.
    const SAMPLE_INPUT = `Green\n  tick -> Yellow\nYellow\n  tick -> Red\nRed\n  tick -> Green`;
    const input = document.querySelector(".the-input > textarea");
    const display = document.querySelector(".the-display > textarea");
    input.value = window.localStorage.getItem("INPUT_STATE") || SAMPLE_INPUT;

    function toArray(txt = "") {
      return txt.split("\n").flatMap(line => {
        line = line.trimEnd();
        return line.length === 0 ? [] : line;
      });
    }

    // Sketch-format parser
    function parser(txt) {
      let currentNode = null;
      const lines = toArray(txt);
      const nodeMap = {}; // map id -> node
      const nameMap = {}; // map name -> node
      const links = [];
      lines.forEach(line => {
        const { indent, type, ...data } = parseLine(line);
        if (type === "node") {
          const node = processNode(data, nameMap);
          nodeMap[node.id] = node;
          nameMap[node.name] = node;
          currentNode = node;
        } else { // assume a link, re-process once all nodes are in.
          const { label, target } = data;
          const node = processNode({ name: target.trim() }, nameMap);
          nodeMap[node.id] = node;
          nameMap[node.name] = node;
          links.push({ src: currentNode.id, tgt: node.id, label });
        }
      })
      return { nodes: Object.values(nodeMap), links, nodeMap };
    }
    let index = 0;

    function parseLine(raw) {
      const indent = raw.search(/\S/);
      const name = raw.trim();
      const link = name.split(" -> ");
      if (link.length > 1) {
        const [label, target] = link;
        return { indent, type: "link", label, target };
      } // otherwise it is a node
      return { indent, type: "node", name };
    }

    function processNode(data, nameMap) {
      const existingNode = nameMap[data.name];
      if (existingNode) {
        return existingNode;
      }
      const id = `n${index++}`;
      const newNode = { ...data, id };
      return newNode;
    }

    let parsed = {};

    input.addEventListener("blur", evt => {
      parsed = parser(evt.target.value);
      window.localStorage.setItem("INPUT_STATE", evt.target.value);
    })

    // Raw format
    document.querySelector("button#b0").addEventListener("click", evt => {
      display.value = JSON.stringify(parsed, null, 3);
    })

    // DOT format
    document.querySelector("button#b1").addEventListener("click", evt => {
      const { nodes, links, nodeMap } = parsed;
      if (!nodes) return;
      const output = ["digraph {",
        ...nodes.map(n => `  ${n.id} [label="${n.name}"]`),
        ...links.map(l => `  ${l.src} -> ${l.tgt} [label="${l.label}"]`),
        "}"
      ];
      display.value = output.join("\n");
    })
    // DOT format, bipartite graph
    document.querySelector("button#b2").addEventListener("click", evt => {
      const { nodes, links, nodeMap } = parsed;
      if (!nodes) return;
      const output = ["digraph {",
        "  node [color=blue shape=box]",
        ...nodes.map(n => `  ${n.id} [label="${n.name}"]`),
        '  node [color="#A0A0A0" shape=oval fontsize="10pt"]',
        ...links.map(l => `  ${l.src}_${l.tgt} [label="${l.label}"]`),
        ...links.map(l => `  ${l.src} -> ${l.src}_${l.tgt}`),
        ...links.map(l => `  ${l.src}_${l.tgt} -> ${l.tgt}`),
        "}"
      ];
      display.value = output.join("\n");
    })

    // Bi-graph systems format
    document.querySelector("button#b3").addEventListener("click", evt => {
      const { nodes, links, nodeMap } = parsed;
      if (!nodes) return;
      const output = { stateNodes: nodes };
      const linkSet = new Set();
      const txnNodes = Object.fromEntries(links.map(lnk => {
        const { src, tgt, label:name } = lnk;
        const id = `${name}_${tgt}`;
        linkSet.add(`${src}:${id}`);
        linkSet.add(`${id}:${tgt}`);
        return [id, {id, name}];
      }));
      output.txnNodes = Object.values(txnNodes);
      output.links = [...linkSet].map(line => {
        const [src, tgt] = line.split(":");
        return { src, tgt };
      });
      console.dir(output);
      const stringified = {
        stateNodes: output.stateNodes.map(node => `${node.id}:${node.name}`),
        transNodes: output.txnNodes.map(node => `${node.id}:${node.name}`),
        links: output.links.map(link => `${link.src} --> ${link.tgt}`)
      }
      display.value = JSON.stringify(stringified, null, 3);
    })

    input.focus();
  }
</script>

</html>
<!-- 
TODO: enhance to allow nested nodes/sub-groups.
Also handle the following:
  NodeName* to indicate default state(s),
  NodeName? to indicate transient states,
  transitionName? to indicate pseudo-events for modelling important internal logic


VisitorView
  userdata loaded -> switchViews
  searching -> SearchView
switchViews
  isPremium -> PremiumView
  isSignedIn -> LoggedInView
  hasOffers -> OffersView
  default -> VisitorView
PremiumView
  searching -> SearchView
LoggedInView
  searching -> SearchView
SearchView
  close-clicked -> switchViews
OffersView

Powered*
  power failed -> Unpowered
  Green
    tick -> Yellow
  Yellow
    tick -> Red
  Red*
    tick -> Green
Unpowered
  power restored -> Powered
  Red On*
    tick -> Red Off
  Red Off
    tick -> Red On

Green
  power failed -> Red On
  tick -> Yellow
Yellow
  power failed -> Red On
  tick -> Red
Red
  power failed -> Red On
  tick -> Green
Red On
  power restored -> Red
  tick -> Red Off
Red Off
  power restored -> Red
  tick -> Red On    
 -->